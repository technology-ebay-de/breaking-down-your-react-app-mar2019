<!doctype html>
<!--suppress RequiredAttributes -->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Breaking Down Your React App</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/pahund.css">

    <!-- Printing and PDF exports -->
    <script>
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img id="ebay-logo" src="images/ebay-tech-logo-wide-light-bgr-small.png" alt="eBay Tech Logo"
     title="eBay Tech Logo">
<div class="reveal">
    <div class="slides">
        <!-- Introduction -->
        <section>
            <img data-src="images/Breaking_Down_Title.png" class="stretch">
            <small>
                Patrick Hund | Lead Frontend Developer | <a target="_blank" href="https://twitter.com/wiekatz">@wiekatz</a>
            </small>
            <aside class="notes">
                Hi everyone, my name is Patrick. I work at eBay in Berlin.
                I'm very excited to be here today to talk about breaking down your React app!
            </aside>
        </section>
        <section data-background-image="images/Green_Field.png" data-background-size="contain">
            <aside class="notes">
                Can anyone tell me what this is?<br><br>
                This is what every developer loves to have when starting a new project: a nice green field,
                everything is possible, the magical chance to get things right this time. To use state-of-the-art
                technology, to build something beautiful that will stand the test of time.
                And, of course, make the customers very, very happy.
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_1.png" data-background-size="contain">
            <aside class="notes">
                So, tadaa, our first release. It’s all good, software craftsmanship at its best. Servers running
                smoothly, high code coverage, only a few bugs and loose ends.
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_2.png" data-background-size="contain">
            <aside class="notes">
                So let’s add some more features. Our app is coming along great!
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_3.png" data-background-size="contain">
            <aside class="notes">
                And some more… but what’s this? Bug rate is increasing? It’s getting harder and harder to
                understand what’s going on in the code. We should fix that! And fix it we will! Eventually! When
                we’re done with the next release, or perhaps the one after that, because rolling out those new
                features is super important!
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_4.png" data-background-size="contain">
            <aside class="notes">
                OK, now the developers are fixing some of the problems, but it’s starting to look more and more
                like we’re just fire fighting, patching up what actually should be torn down and rebuilt from
                scratch.<br><br>
                In the many years I’ve been working as a software developer, I’ve seen this happen time and time
                again. There’s nothing I’m quite as passionate about as finding ways to prevent this phenomenon
                known as:
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_4_Background.png" data-background-size="contain">
            <h1>Software Entropy</h1>
            <h2>Accumulation of Technical Debt</h2>
            <aside class="notes">
                Software Entropy.<br><br>
                While software is actively being worked on, its complexity is constantly increasing, technical
                debt is accumulated, the software becomes harder and harder to modify without breaking things. At
                some point, the cost of fixing it is higher than the cost of rewriting it from scratch.
            </aside>
        </section>
        <section>
            <figure class="stretch">
                <img data-src="images/Tech_Debt_Graph.png">
                <figcaption>
                    (source: <a
                        target="_blank"
                        href="https://www.informatik-aktuell.de/entwicklung/methoden/langlebige-architekturen-technische-schulden-erkennen-und-beseitigen.html">Dr.
                    Carola Lilienthal</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                To prevent this, you have to refactor your code base periodically. It’s not just about fixing
                bugs, it’s about keeping your code clean, about making it consistent.<br><br>
                It’s OK to make some debt, but you have to make sure you have recurring phases of paying off that
                debt, lest it become too great and make cleaning up too costly.
            </aside>
        </section>
        <section>
            <img class="stretch" data-src="images/Tech_Debt_Graph_With_Looping.png">
            <aside class="notes">
                Otherwise you'll get to a point where the cost of maintaining your code base and adding new
                features is so high that there is no other way than doing a full rewrite.
            </aside>
        </section>
        <section>
            <img data-src="images/React_Logo.png" class="stretch">
            <aside class="notes">
                So what does all that have to do with React?<br><br>
                What makes React so special to me is that it is based on components. You break down your
                application into neat little parts and work on them separately. You compose your application from
                building blocks, like Lego bricks.
            </aside>
        </section>
        <section data-background-image="images/Lego_Webpage_Disassembled.png" data-background-size="contain">
            <aside class="notes">
                If you use React right, you can create a set of loosely coupled components, with well defined
                purpose.
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Building_1.png" data-background-size="contain">
            <aside class="notes">
                You can use that set of building blocks to build your pages. You can work on each component
                separately, you can even split them into independent npm packages and versionize them.
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Building_2.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Building_3.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Building_4.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Assembled.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Fancy_Assembling.png" data-background-size="contain">
            <aside class="notes">
                If a part of your application needs to be extended or renewed, you can throw away the old
                components and replace them with shiny, new ones. In the pre-component age, with a tightly
                coupled, monolithic application, this was expensive and time consuming, much less now.<br><br>
                React gives us the chance to make this dream come true, but it does not come automatically
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Fancy_New_Header.png" data-background-size="contain">
        </section>

        <section>
            <h3>Big Ball of Mud</h3>
            <img class="stretch" data-src="images/Big_Ball_of_Mud.png">
            <h4>React Component Spaghetti</h4>
            <aside class="notes">
                Just because you are using React doesn’t mean you a clean, well structured codebase
                automatically. You can create a “big ball of mud" with React just as well as you can with jQuery
                or anything else.
            </aside>
        </section>

        <section>
            <h2>Divide and Conquer</h2>
            <img class="stretch" data-src="images/Breaking_Down_Logo_Only.png" style="margin: -40px 0">
            <h2>Best Practices</h2>
            <aside class="notes">
                So what are some best practices to leverage the power of components in your React application?
                How do you actually break down your React app?<br><br>
                Let's do a quick recap of the most basic practices that we use at eBay, and I'm sure most
                of you do in your work, too.
            </aside>
        </section>

        <section>
            <img data-src="images/Presentational_And_Container_Components.png" class="stretch">
            <h3>Separate presentational<br>and container components</h3>
            <aside class="notes">
                In React, you can happily mix up your UI logic, your business logic and your JSX template
                code. That doesn't mean you should, though – it's the shortest path to the before mentioned
                steaming bowl of spaghetti code.<br><br>
                Instead, you create make your presentational components “dumb” by spoon feeding them with
                the props they should display, and you wrap them in container components, or “smart”
                components, that prepare those props.<br><br>
                Higher order components or render props are commonly used patterns for these. I personally
                love to use Andrew Clarke's recompose library.
            </aside>
        </section>

        <section>
            <img data-src="images/storybook-screenshot.png" class="stretch box-shadow">
            <h3>Organize presentational components<br>in a separate style guide</h3>
            <aside class="notes">
                Once you've separated presentational components, you can use them to create a living style
                guid, using tools like Storybook or React Styleguidist.<br><br>
                Here's a screenshot from the styleguide we use for our website.
            </aside>
        </section>

        <!--section>
            <div class="PH_TODO">monorepos</div>
        </section-->

        <!--section>
            <img data-src="images/Architecture_Schema_API_and_App.png" class="stretch">
            <h3>Separate application server and API server</h3>
        </section-->

        <section>
            <h3>Separation of Concerns</h3>
            <figure class="stretch">
                <img data-src="images/Separation_of_Concerns_20th_Century.png">
                <figcaption>
                    (source: <a target="_blank" href="http://speakerdeck.com/didoo/let-there-be-peace-on-css">Cristiano
                    Rastelli</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                So let's talk about “separation of concerns”, a term you probably remember from your computer
                science classes, but what does it actually mean from a frontend developer's perspective?<br><br>
                In the early days of web programming, frontend developers tended to think it means:
                You have HTML, which is concerned with stucturing the information you display on a web page,
                you have CSS, which is concerned with making it pretty, and you have JavaScript to make it
                wiggle when you click on it, or whatever.<br><br>
                But we live in the 21st century now, what some people call the component age, and there is
                a better way to define separation of concerns:
            </aside>
        </section>

        <section>
            <h3>Separation of Concerns</h3>
            <figure class="stretch">
                <img data-src="images/Separation_of_Concerns.png"
                     onclick="this.src = 'images/Separation_of_Concerns_JS.png';">
                <figcaption>
                    (source: <a target="_blank" href="http://speakerdeck.com/didoo/let-there-be-peace-on-css">Cristiano
                    Rastelli</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                The concerns that should be separated are the features of the app, the lego bricks that I'm
                building my app of, each containing their own HTML, CSS and JavaScript<br><br>
                Although, with React, the graphic perhaps should look more like this (<em>click right graph</em>)<br><br>
                At this point I have to admit I stepped into the trap of this old school way of thinking
                of separating concerns not by feature, but by type of tool. Let me show you what I mean.
            </aside>
        </section>

        <section>
            <div style="display: flex; align-items: center; justify-content: space-between" class="stretch">
                <div class="box-shadow" style="overflow: hidden; width: 525px; height: 667px;">
                    <div style="overflow-y: scroll; overflow-x: hidden; width: 525px; height: 100%; background: #fff;">
                        <img data-src="images/Dir_Structure_Before_Blurred.png"
                             onclick="this.src = 'images/Dir_Structure_Before.png';"
                             style="margin: 0; width: 525px; height: 1854px; max-width: inherit; max-height: inherit">
                    </div>
                </div>
                <div style="width: 32px"></div>
                <div class="box-shadow" style="overflow: hidden; width: 525px; height: 667px">
                    <div style="overflow-y: scroll; overflow-x: hidden; width: 525px; height: 100%; background: #fff;">
                        <img data-src="images/Dir_Structure_After_Blurred.png"
                             onclick="this.src = 'images/Dir_Structure_After.png';"
                             style="margin: 0; width: 525px; height: 1854px; max-width: inherit; max-height: inherit">
                    </div>
                </div>
            </div>
            <aside class="notes">
                This is how we organized the JavaScript modules of our app at first
                (<em>click left box</em>). As you can see, we are using Redux, so we created directories
                for our presentational components, our containers, our actions, our reducers and selectors,
                all nicely sorted by module type, and at the root, one source and one test directory for
                unit tests, which has the same structure as the source directory<br><br>
                This is basically the same way of organizing things in the old days, when separation of concerns
                meant separating HTML, CSS and JavaScript.<br><br>
                It's OK for a small app, but as the codebase grows, you wind up with directories with
                hundreds of modules. <br><br>
                My colleagues and I got together and discussed a better way to organize our code, this is
                what we came up with: (<em>click right box</em>)<br><br>
                We put each feature of our website in its own directory, so in this example taken from our
                discussion forum, we have one directory for a feature that displays a list of discussion boards,
                and another one for a feature that displays a list of discussion threads within a board.
                Each has its own components, reducers, actions, and so one, and each directory has its
                own index.js file that defines a clear interface to the parent application that uses the feature.<br><br>
                This was the first step on our journey to achieving properly decoupled modules. Or should me
                even call them modules? That term is already used for many, many things, so we came up with
                our own term to call them:
            </aside>
        </section>
        <section>
            <h1>Bricks</h1>
            <img class="stretch" data-src="images/Breaking_Down_Logo_Only.png" style="margin: -40px 0">
            <aside class="notes">
                Bricks – the building blocks of our web applications, like putting Lego bricks together.
            </aside>
        </section>

        <!--section>
            <img data-src="images/Fractals.png" class="stretch">
        </section-->

        <section data-background-image="images/Lego_Webpage_Hacker_News.png" data-background-size="contain">
            <aside class="notes">
                It's about time to get more practical and show some actual code. I'll use an example brick
                I've made throughout the rest of my talk. It shows the latest headlines from Hacker News.
                My Hacker News brick is a little application within my main application that uses Redux to
                display some data to the user.
            </aside>
        </section>

        <section>
            <iframe data-src="https://codesandbox.io/embed/mok6364lmx?hidenavigation=1&view=preview"
                    class="stretch box-shadow"
                    style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
                    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
            <aside class="notes">
                It looks like this. It preloads its data from the global Redux state, and when you
                hit the “Update” button, it updates its content from the Hacker News API.
            </aside>
        </section>

        <section>
            <video controls class="stretch">
                <source data-src="images/Redux_Movie.mp4" type="video/mp4"/>
            </video>
            <aside class="notes">
                For those who are not familiar with how Redux works, let's do a quick recap:
                (<em>start video</em>)<br><br>
                The container component gets a prop “top stories” from the Redux state.
                Except it doesn't, top stories is null at this point.<br><br>
                So the container renders a spinner on the webpage and dispatches an action to start
                loading the top stories.<br><br>
                Data loading is a side effect which happens asynchronously, this is handled by a saga,
                which gets triggered by the action. It fetches the data from the Hacker News API
                and then dispatches another action with the data as payload<br><br>
                This is picked up by the reducer, which produces a new version of the Redux state
                with the data.<br><br>
                The container is connected to the state and reacts to the state change by
                replacing the spinner component with the presentational component that displays the data.
            </aside>
        </section>

        <section data-transition="slide-in fade-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_0.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
<mark class="disabled">export { default as HackerNews } from './components';
export * from './src/actions';
export { default as reducer } from './reducer';
export { default as saga } from './sagas';
export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                There is a contract we have about our bricks: each brick shall have one index.js
                file in its root directory which provides exports of the five parts of the brick
                that need to be integrated in the parent application.
            </aside>
        </section>
        <section data-transition="fade-in fade-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_1.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
<mark>export { default as HackerNews } from './components';</mark>
<mark class="disabled">export * from './src/actions';
export { default as reducer } from './reducer';
export { default as saga } from './sagas';
export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                Each brick exports one main React component, which is usually a container
                connected to the Redux store. In case of our Hacker News Brick, this is the
                component that renders the box with the latest news.
            </aside>
        </section>
        <section data-transition="fade-in fade-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_2.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
export { default as HackerNews } from './components';
<mark>export * from './src/actions';</mark>
<mark class="disabled">export { default as reducer } from './reducer';
export { default as saga } from './sagas';
export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                Then each brick exports one or more action creator functions, which allow the
                parent app – or even other bricks – to send signals to our brick to make them
                do things. In case of our HackerNews brick, there is an action that triggers
                updating the Hacker News stories.
            </aside>
        </section>
        <section data-transition="fade-in fade-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_3.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
export { default as HackerNews } from './components';
export * from './src/actions';
<mark>export { default as reducer } from './reducer';</mark>
<mark class="disabled">export { default as saga } from './sagas';
export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                Each brick has a reducer that updates the Redux state in response to actions
                being dispatched. This reducer is combined with the reducer of the parent
                application.
            </aside>
        </section>
        <section data-transition="fade-in fade-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_4.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
export { default as HackerNews } from './components';
export * from './src/actions';
export { default as reducer } from './reducer';
<mark>export { default as saga } from './sagas';</mark>
<mark class="disabled">export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                Each brick has one Redux saga that is run by the parent application. Sagas
                are for handling side effects such as data loading through a Redux middleware.
            </aside>
        </section>
        <section data-transition="fade-in slide-out">
            <div class="columns-container">
                <div class="column-one-third" style="margin: 0 -50px 0 0">
                    <img data-src="images/Five_Stud_Lego_Brick_5.png">
                </div>
                <div class="column-two-thirds">
                    <h4 class="nocaps">index.js</h4>
                    <pre class="box-shadow"><code data-trim data-noescape>
export { default as HackerNews } from './components';
export * from './src/actions';
export { default as reducer } from './reducer';
export { default as saga } from './sagas';
<mark>export { default as selectors } from './selectors';</mark>
                    </code></pre>
                </div>
            </div>
            <aside class="notes">
                Finally, each brick exports an object with selector functions that
                are used to pick data from the Redux state. Why not just access the
                Redux state directly?
            </aside>
        </section>

        <section>
            <img class="stretch" data-src="images/State_And_Components.png">
            <aside class="notes">
                Well, there is always only one global Redux state as single source of
                truth. This is one of the big advantages of Redux: you can look at the
                state at any point to see exactly what's going on. Your Hacker News
                brick has its own place in that state. If we access the state from
                the HackerNews component directly, we'll have to make sure that
                the path to the data in the state is always exactly the same –
                in this case modules > hackerNews. By using selectors, we can put the
                state of our brick anywhere, and we only have to change a single line of
                code to do it:
            </aside>
        </section>

        <section data-transition="slide-in fade-out">
            <h4 class="nocaps">registerSelectors.js</h4>
            <pre class="box-shadow"><code data-trim data-noescape>
<mark class="disabled">import { registerSelectorsForUseWithGlobalState } from "@modular-toolkit/selectors";
import { selectors as hackerNews } from "@modular-toolkit/demo-module";</mark>

const selectorMapping = {
  <mark>"modules.hackerNews": hackerNews</mark>
};

<mark class="disabled">export default () => {
  for (const [path, selectors] of Object.entries(selectorMapping)) {
    registerSelectorsForUseWithGlobalState(path, selectors);
  }
};</mark>
            </code></pre>
            <aside class="notes">
                In this code snipped taken from the demo I've showed you,
                we define the path for our bricks with a path string.
            </aside>
        </section>

        <section data-transition="fade-in fade-out">
            <h4 class="nocaps">registerSelectors.js</h4>
            <pre class="box-shadow"><code data-trim data-noescape>
<mark class="disabled">import { registerSelectorsForUseWithGlobalState } from "@modular-toolkit/selectors";</mark>
import { selectors as <mark>hackerNews</mark> } from "@modular-toolkit/demo-module";

const selectorMapping = {
  <mark>"bricks.widgets.hackerNews": hackerNews</mark>
};

<mark class="disabled">export default () => {
  for (const [path, selectors] of Object.entries(selectorMapping)) {
    registerSelectorsForUseWithGlobalState(path, selectors);
  }
};</mark>
            </code></pre>
            <aside class="notes">
                In this code snipped taken from the demo I've showed you,
                we define the path for our bricks with a path string.
            </aside>
        </section>

        <section data-transition="fade-in fade-out">
            <h4 class="nocaps">registerSelectors.js</h4>
            <pre class="box-shadow"><code data-trim data-noescape>
import { <mark>registerSelectorsForUseWithGlobalState</mark> } from "@modular-toolkit/selectors";
<mark class="disabled">import { selectors as hackerNews } from "@modular-toolkit/demo-module";

const selectorMapping = {
  "bricks.widgets.hackerNews": hackerNews
};

export default () => {
  for (const [path, selectors] of Object.entries(selectorMapping)) {</mark>
    <mark>registerSelectorsForUseWithGlobalState</mark>(path, selectors);
  <mark class="disabled">}
};</mark>
            </code></pre>
            <aside class="notes">
                We used a little trick to be able to do this:
                in the registerSelectorsForUseWithGlobalState, which is
                just eight lines of code, we store the path as a property
                of the selector function. In the brick's container component,
                instead of using Redux's connect function directly, we use
                out own version which reads this path and “rebases” the
                selectors to point to the correct part of the state.
            </aside>
        </section>

        <section data-transition="fade-in fade-out">
            <h4 class="nocaps">rootReducer.js</h4>
            <pre class="box-shadow"><code data-trim data-noescape>
<mark class="disabled">import { combineReducers } from "redux";</mark>

import { reducer as <mark>hackerNews</mark> } from "@modular-toolkit/demo-module";

<mark class="disabled">export default combineReducers({</mark>
  bricks: combineReducers({
    <mark>hackerNews</mark>
  })
<mark class="disabled">});</mark>
            </code></pre>
            <aside class="notes">
                So we've seen how to connect the Brick's selectors. To be able to
                use the brick in our app, we have to do two more things:
                first, add the brick's reducer to the app's reducers. We are using
                the combineReducers function from the Redux library here to be
                able to deep nest our reducer, and combine it with reducers from
                other bricks, or from the parent application.
            </aside>
        </section>

        <section data-transition="fade-in fade-out">
            <h4 class="nocaps">configureStore.js</h4>
            <pre class="box-shadow"><code data-trim data-noescape>
<mark class="disabled">import { applyMiddleware, createStore } from "redux";
import createSagaMiddleware from "redux-saga";
import reducer from "./reducer";</mark>
import { <mark>saga</mark> } from '@modular-toolkit/demo-module';

<mark class="disabled">export default () => {
  const sagaMiddleware = createSagaMiddleware();
  const store = createStore(reducer, applyMiddleware(sagaMiddleware));</mark>
  sagaMiddleware.run(<mark>saga</mark>);
  <mark class="disabled">return store;
};</mark>
            </code></pre>
            <aside class="notes">
                The last piece of the puzzle that's missing to wire up our brick
                is running its saga, which we do using the Redux saga middleware.
            </aside>
        </section>

        <section data-transition="fade-in fade-out">
            <iframe data-src="https://codesandbox.io/embed/v2137r7k7?hidenavigation=1&module=%2Fsrc%2Fpages%2Fhome%2Fcomponents%2FHomePage.js"
                    class="stretch box-shadow"
                    style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
                    sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
            <aside class="notes">
                So that's it! Now I can just drop my HackerNews components anywhere in my
                page, just as if it were a simple presentational component. It will load
                its data automatically when it is mounted, or I could dispatch an update
                action to make it update.
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Assembled.png" data-background-size="contain">
        </section>

        <!-- Summary, End -->
        <section>
            <img class="stretch" data-src="images/Pretty_Lego_Castle.png">
        </section>
        <section>
            <h2>Thank you!</h2>
            <table class="credits">
                <tr>
                    <td>
                        <p class="name">Ninja Maaß
                        <p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Daniel Schäfer</p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Eike Schulte-Kersmecke</p>
                        <p class="function">Backend Developer</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Anja Kunkel</p>
                        <p class="function">Backend Developer</p>
                    </td>
                    <td>
                        <p class="name">Torsten Walter</p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Juho Vepsäläinen</p>
                        <p class="function">Dev Consultant</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Mike Krüger</p>
                        <p class="function">Quality Assurance</p>
                    </td>
                    <td>
                        <p class="name">Hajo Skwirblies</p>
                        <p class="function">Site Operations</p>
                    </td>
                    <td>
                        <p class="name">Florian Stefan</p>
                        <p class="function">Architect</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Christoph Springer</p>
                        <p class="function">Team Lead</p>
                    </td>
                    <td>
                        <p class="name">Julia Thiele</p>
                        <p class="function">Product Owner</p>
                    </td>
                    <td>
                        <p class="name">Jakob Gehring</p>
                        <p class="function">Product Owner</p>
                    </td>
                </tr>
            </table>
            <p>
                View this presentation online: <a target="_blank" href="http://bit.ly/break-react">bit.ly/break-react</a>
            </p>
            <p class="small">
                Patrick Hund | Lead Frontend Developer | <a target="_blank" href="https://twitter.com/wiekatz">@wiekatz</a><br>
                Copyright © 2018 mobile.de GmbH
            </p>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    Reveal.initialize({
        width: 1280,
        height: 720,
        history: true,
        dependencies: [
            { src: 'plugin/markdown/marked.js' },
            { src: 'plugin/markdown/markdown.js' },
            { src: 'plugin/notes/notes.js', async: true },
            { src: 'socket.io/socket.io.js', async: true },
            { src: 'plugin/notes-server/client.js', async: true },
            {
                src: 'plugin/highlight/highlight.js',
                async: true,
                callback() {
                    // noinspection ES6ModulesDependencies, JSUnresolvedVariable
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
