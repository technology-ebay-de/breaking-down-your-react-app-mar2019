<!doctype html>
<!--suppress RequiredAttributes -->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Breaking Down Your React App</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/pahund.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<img id="ebay-logo" src="images/ebay-tech-logo-wide-light-bgr-small.png" alt="eBay Tech Logo"
     title="eBay Tech Logo">
<div class="reveal">
    <div class="slides">
        <!-- Introduction -->
        <section>
            <img data-src="images/Breaking_Down_Title.png" class="stretch">
            <small>
                Patrick Hund | Lead Frontend Developer | <a target="_blank" href="https://twitter.com/wiekatz">@wiekatz</a>
            </small>
            <aside class="notes">
                Hi everyone, my name is Patrick. I work at eBay in Berlin.
            </aside>
        </section>
        <section data-background-image="images/Green_Field.png" data-background-size="contain">
            <aside class="notes">
                Can anyone tell me what this is?<br><br>
                This is what every developer loves to have when starting a new project: a nice green field,
                everything is possible, the magical chance to get things right this time. To use state-of-the-art
                technology, to build something beautiful that will stand the test of time.
                And, of course, make the customers very, very happy.
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_1.png" data-background-size="contain">
            <aside class="notes">
                So, tadaa, our first release. It’s all good, software craftsmanship at its best. Servers running
                smoothly, high code coverage, only a few bugs and loose ends.
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_2.png" data-background-size="contain">
            <aside class="notes">
                So let’s add some more features. Our app is coming along great!
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_3.png" data-background-size="contain">
            <aside class="notes">
                And some more… but what’s this? Bug rate is increasing? It’s getting harder and harder to
                understand what’s going on in the code. We should fix that! And fix it we will! Eventually! When
                we’re done with the next release, or perhaps the one after that, because rolling out those new
                features is super important!
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_4.png" data-background-size="contain">
            <aside class="notes">
                OK, now the developers are fixing some of the problems, but it’s starting to look more and more
                like we’re just fire fighting, patching up what actually should be torn down and rebuilt from
                scratch.<br><br>
                In the many years I’ve been working as a software developer, I’ve seen this happen time and time
                again. There’s nothing I’m quite as passionate about as finding ways to prevent this phenomenon
                known as:
            </aside>
        </section>
        <section data-background-image="images/Castle_Phase_4_Background.png" data-background-size="contain">
            <h1>Software Entropy</h1>
            <h2>Accumulation of Technical Debt</h2>
            <aside class="notes">
                Software Entropy.<br><br>
                While software is actively being worked on, its complexity is constantly increasing, technical
                debt is accumulated, the software becomes harder and harder to modify without breaking things. At
                some point, the cost of fixing it is higher than the cost of rewriting it from scratch.
            </aside>
        </section>
        <section>
            <figure class="stretch">
                <img data-src="images/Tech_Debt_Graph.png">
                <figcaption>
                    (source: <a
                        target="_blank"
                        href="https://www.informatik-aktuell.de/entwicklung/methoden/langlebige-architekturen-technische-schulden-erkennen-und-beseitigen.html">Dr.
                    Carola Lilienthal</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                To prevent this, you have to refactor your code base periodically. It’s not just about fixing
                bugs, it’s about keeping your code clean, about making it consistent.<br><br>
                It’s OK to make some debt, but you have to make sure you have recurring phases of paying off that
                debt, lest it become too great and make cleaning up too costly.
            </aside>
        </section>
        <section>
            <img class="stretch" data-src="images/Tech_Debt_Graph_With_Looping.png">
            <aside class="notes">
                Otherwise you'll get to a point where the cost of maintaining your code base and adding new
                features is so high that there is no other way than doing a full rewrite.
            </aside>
        </section>
        <section>
            <img data-src="images/React_Logo.png" class="stretch">
            <aside class="notes">
                So what does all that have to do with React?<br><br>
                What makes React so special to me is that it is based on components. You break down your
                application into neat little parts and work on them separately. You compose your application from
                building blocks, like Lego bricks.
            </aside>
        </section>
        <section data-background-image="images/Lego_Webpage_Disassembled.png" data-background-size="contain">
            <aside class="notes">
                If you use React right, you can create a set of loosely coupled components, with well defined
                purpose.
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Building_1.png" data-background-size="contain">
            <aside class="notes">
                You can use that set of building blocks to build your pages. You can work on each component
                separately, you can even split them into independent npm packages and versionize them.
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Building_2.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Building_3.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Building_4.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Assembled.png" data-background-size="contain">
        </section>

        <section data-background-image="images/Lego_Webpage_Fancy_Assembling.png" data-background-size="contain">
            <aside class="notes">
                If a part of your application needs to be extended or renewed, you can throw away the old
                components and replace them with shiny, new ones. In the pre-component age, with a tightly
                coupled, monolithic application, this was expensive and time consuming, much less now.<br><br>
                React gives us the chance to make this dream come true, but it does not come automatically
            </aside>
        </section>

        <section data-background-image="images/Lego_Webpage_Fancy_New_Header.png" data-background-size="contain">
        </section>

        <section>
            <h3>Big Ball of Mud</h3>
            <img class="stretch" data-src="images/Big_Ball_of_Mud.png">
            <h4>React Component Spaghetti</h4>
            <aside class="notes">
                Just because you are using React doesn’t mean you a clean, well structured codebase
                automatically. You can create a “big ball of mud" with React just as well as you can with jQuery
                or anything else.
            </aside>
        </section>

        <section>
            <h2>Divide and Conquer</h2>
            <img class="stretch" data-src="images/Breaking_Down_Logo_Only.png" style="margin: -40px 0">
            <h2>Best Practices</h2>
            <aside class="notes">
                So what are some best practices to leverage the power of components in your React application?
                How do you actually break down your React app?<br><br>
                Let's do a quick recap of the most basic practices that we use at eBay, and I'm sure most
                of you do in your work, too.
            </aside>
        </section>

        <section>
            <img data-src="images/Presentational_And_Container_Components.png" class="stretch">
            <h3>Separate presentational<br>and container components</h3>
            <aside class="notes">
                In React, you can happily mix up your UI logic, your business logic and your JSX template
                code. That doesn't mean you should, though – it's the shortest path to the before mentioned
                steaming bowl of spaghetti code.<br><br>
                Instead, you create make your presentational components “dumb” by spoon feeding them with
                the props they should display, and you wrap them in container components, or “smart”
                components, that prepare those props.<br><br>
                Higher order components or render props are commonly used patterns for these. I personally
                love to use Andrew Clarke's recompose library.
            </aside>
        </section>

        <section>
            <img data-src="images/storybook-screenshot.png" class="stretch box-shadow">
            <h3>Organize presentational components<br>in a separate style guide</h3>
            <aside class="notes">
                Once you've separated presentational components, you can use them to create a living style
                guid, using tools like Storybook or React Styleguidist.<br><br>
                Here's a screenshot from the styleguide we use for our website.
            </aside>
        </section>

        <section>
            <div class="PH_TODO">monorepos</div>
        </section>

        <!--section>
            <img data-src="images/Architecture_Schema_API_and_App.png" class="stretch">
            <h3>Separate application server and API server</h3>
        </section-->

        <section>
            <h3>Separation of Concerns</h3>
            <figure class="stretch">
                <img data-src="images/Separation_of_Concerns_20th_Century.png">
                <figcaption>
                    (source: <a target="_blank" href="http://speakerdeck.com/didoo/let-there-be-peace-on-css">Cristiano
                    Rastelli</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                So let's talk about “separation of concerns”, a term you probably remember from your computer
                science classes, but what does it actually mean from a frontend developer's perspective?<br><br>
                In the early days of web programming, frontend developers tended to think it means:
                You have HTML, which is concerned with stucturing the information you display on a web page,
                you have CSS, which is concerned with making it pretty, and you have JavaScript to make it
                wiggle when you click on it, or whatever.<br><br>
                But we live in the 21st century now, what some people call the component age, and there is
                a better way to define separation of concerns:
            </aside>
        </section>

        <section>
            <h3>Separation of Concerns</h3>
            <figure class="stretch">
                <img data-src="images/Separation_of_Concerns.png"
                     onclick="this.src = 'images/Separation_of_Concerns_JS.png';">
                <figcaption>
                    (source: <a target="_blank" href="http://speakerdeck.com/didoo/let-there-be-peace-on-css">Cristiano
                    Rastelli</a>)
                </figcaption>
            </figure>
            <aside class="notes">
                The concerns that should be separated are the features of the app, the lego bricks that I'm
                building my app of, each containing their own HTML, CSS and JavaScript<br><br>
                Although, with React, the graphic perhaps should look more like this (<em>click right graph</em>)<br><br>
                At this point I have to admit I stepped into the trap of this old school way of thinking
                of separating concerns not by feature, but by type of tool. Let me show you what I mean.
            </aside>
        </section>

        <section>
            <div style="display: flex; align-items: center; justify-content: space-between" class="stretch">
                <div class="box-shadow" style="overflow: hidden; width: 525px; height: 667px;">
                    <div style="overflow-y: scroll; overflow-x: hidden; width: 525px; height: 100%; background: #fff;">
                        <img data-src="images/Dir_Structure_Before_Blurred.png"
                             onclick="this.src = 'images/Dir_Structure_Before.png';"
                             style="margin: 0; width: 525px; height: 1854px; max-width: inherit; max-height: inherit">
                    </div>
                </div>
                <div style="width: 32px"></div>
                <div class="box-shadow" style="overflow: hidden; width: 525px; height: 667px">
                    <div style="overflow-y: scroll; overflow-x: hidden; width: 525px; height: 100%; background: #fff;">
                        <img data-src="images/Dir_Structure_After_Blurred.png"
                             onclick="this.src = 'images/Dir_Structure_After.png';"
                             style="margin: 0; width: 525px; height: 1854px; max-width: inherit; max-height: inherit">
                    </div>
                </div>
            </div>
            <aside class="notes">
                This is how we organized the JavaScript modules of our app at first
                (<em>click left box</em>). As you can see, we are using Redux, so we created directories
                for our presentational components, our containers, our actions, our reducers and selectors,
                all nicely sorted by module type, and at the root, one source and one test directory for
                unit tests, which has the same structure as the source directory<br><br>
                This is basically the same way of organizing things in the old days, when separation of concerns
                meant separating HTML, CSS and JavaScript.<br><br>
                It's OK for a small app, but as the codebase grows, you wind up with directories with
                hundreds of modules. <br><br>
                My colleagues and I got together and discussed a better way to organize our code, this is
                what we came up with: (<em>click right box</em>)<br><br>
                We put each feature of our website in its own directory, so in this example taken from our
                discussion forum, we have one directory for a feature that displays a list of discussion boards,
                and another one for a feature that displays a list of discussion threads within a board.
                Each has its own components, reducers, actions, and so one, and each directory has its
                own index.js file that defines a clear interface to the parent application that uses the feature.<br><br>
                This was the first step on our journey to achieving properly decoupled modules. Or should me
                even call them modules? That term is already used for many, many things, so we came up with
                our own term to call them:
            </aside>
        </section>
        <section>
            <h1>Bricks</h1>
            <img class="stretch" data-src="images/Breaking_Down_Logo_Only.png" style="margin: -40px 0">
            <aside class="notes">
                Bricks – the building blocks of our web applications, like putting Lego bricks together.
            </aside>
        </section>

        <!--section>
            <img data-src="images/Fractals.png" class="stretch">
        </section-->

        <section data-background-image="images/Lego_Webpage_Hacker_News.png" data-background-size="contain">
            <aside class="notes">
                It's about time to get more practical and show some actual code. I'll use an example brick
                I've made throughout the rest of my talk. It shows the latest headlines from Hacker News.
                My Hacker News brick is a little application within my main application that uses Redux to
                display some data to the user.
            </aside>
        </section>

        <section>
            <video controls class="stretch">
                <source data-src="images/Redux_Movie.mp4" type="video/mp4"/>
            </video>
            <aside class="notes">
                For those who are not familiar with how Redux works, let's do a quick recap:
                (<em>start video</em>)<br><br>
                The container component gets a prop “top stories” from the Redux state.
                Except it doesn't, top stories is null at this point.<br><br>
                So the container renders a spinner on the webpage and dispatches an action to start
                loading the top stories.<br><br>
                Data loading is a side effect which happens asynchronously, this is handled by a saga,
                which gets triggered by the action. It fetches the data from the Hacker News API
                and then dispatches another action with the data as payload<br><br>
                This is picked up by the reducer, which produces a new version of the Redux state
                with the data.<br><br>
                The container is connected to the state and reacts to the state change by
                replacing the spinner component with the presentational component that displays the data.
            </aside>
        </section>

        <section>
            <img class="stretch" data-src="images/Pretty_Lego_Castle.png">
        </section>

        <!-- Summary, End -->
        <section>
            <h2>Thank you!</h2>
            <table class="credits">
                <tr>
                    <td>
                        <p class="name">Ninja Maaß
                        <p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Daniel Schäfer</p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Eike Schulte-Kersmecke</p>
                        <p class="function">Backend Developer</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Anja Kunkel</p>
                        <p class="function">Backend Developer</p>
                    </td>
                    <td>
                        <p class="name">Torsten Walter</p>
                        <p class="function">Frontend Developer</p>
                    </td>
                    <td>
                        <p class="name">Juho Vepsäläinen</p>
                        <p class="function">Dev Consultant</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Mike Krüger</p>
                        <p class="function">Quality Assurance</p>
                    </td>
                    <td>
                        <p class="name">Hajo Skwirblies</p>
                        <p class="function">Site Operations</p>
                    </td>
                    <td>
                        <p class="name">Florian Stefan</p>
                        <p class="function">Architect</p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p class="name">Christoph Springer</p>
                        <p class="function">Team Lead</p>
                    </td>
                    <td>
                        <p class="name">Julia Thiele</p>
                        <p class="function">Product Owner</p>
                    </td>
                    <td>
                        <p class="name">Jakob Gehring</p>
                        <p class="function">Product Owner</p>
                    </td>
                </tr>
            </table>
            <p>
                View this presentation online: <a target="_blank" href="http://bit.ly/break-react">bit.ly/break-react</a>
            </p>
            <p class="small">
                Patrick Hund | Lead Frontend Developer | <a target="_blank" href="https://twitter.com/wiekatz">@wiekatz</a><br>
                Copyright © 2018 mobile.de GmbH
            </p>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'plugin/markdown/marked.js' },
            { src: 'plugin/markdown/markdown.js' },
            { src: 'plugin/notes/notes.js', async: true },
            { src: 'socket.io/socket.io.js', async: true },
            { src: 'plugin/notes-server/client.js', async: true },
            {
                src: 'plugin/highlight/highlight.js',
                async: true,
                callback() {
                    // noinspection ES6ModulesDependencies, JSUnresolvedVariable
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
